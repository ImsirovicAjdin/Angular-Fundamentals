import { Directive } from '@angular/core';
import { Validator, FormGroup } from '@angular/forms';

@Directive({
    selector: '[validateLocation]',
})
export class LocationValidator implements Validator {
    validate(formGroup: FormGroup): { [key: string]: any } {
        let addressControl = formGroup.controls['address'];
        let cityControl = formGroup.controls['city'];
        let countryControl = formGroup.controls['coutnry'];
        let onlineUrlControl = (<FormGroup>formGroup.root).controls['onlineUrl'];

        if((addressControl && addressControl.value) || (onlineUrlControl && onlineUrlControl.value)) {
            return null;
        } else {
            return {validateLocation: false}
        }
    }
}

/*
13.06 Creating a Custom Validator
Before we finish up this module, we're going to create one last directive. Remember in our createEvent form, we have an eventLocation and an online URL. Now when the user's creating an event, they either need to give the location, including all three fields, or give the online URL and that's what makes the form valid. Right now there's no validation around these fields, you don't have to fill these in. The other fields are required, but not these ones. So we want to create a custom directive that will validate this, make sure that they've either filled out all three of these fields, address, city or country, or they filled out the online URL. This is not something that angular will handle by default, so we've got to do this ourselves. Let's take a quick look at the HTML for the createEvent form. Here inside of events, it's down in this create event component dot HTML. Close this other stuff up. All right, here is the HTML for our form and the relevant part is down here. We have this model group called location and that wraps around the event location which is the address, the city and the country. That's this model group here. And then we've got a different form group, which is the online URL. Now we need a custom validator that will apply to both of these. Unfortunately, since they're sibling nodes, it's not going to be easy to create this custom validator, because it will be put on of those nodes, probably this node up here, but it will need to access both of these nodes. So this is going to be a fairly business-specific validator. What we want to do then is to add the validator to this node as a directive, something like validateLocation, and once we add that validator to this node, then we want it to apply the validation, these custom validation rules we're talking about. Let's go ahead and get started with that by creating our custom validator directive. Since this is fairly business-specific, I'm not going to put it in the shared folder, instead I'm going to put it right along side the create event page itself. And we'll call this a location validator, it's a directive, and so we're going to need to import directive from angular core, and now we can create our skeleton directive, and of course, we need to give our directive a selector, and it's going to be the attribute validateLocation, which we saw over in our HTML. That's the attribute we want to use, save that file. And we're going to add another piece of this directive in a minute, but I'm going to leave this alone for the moment. We're going to export our class. I'm going to call it LocationValidator, even though it's a directive, I'm not going to add the directive suffix, just the validator suffix. And since it's a validator, it can implement the validator interface, which comes from angular forms, so let's bring that in. There's our interface Validator, we'll implement that. And that means that this class needs to implement a function called validate, which takes in one parameter which is a form group, and I'm going to call that control, and the type is FormGroup, which we can get from angular forms as well. And that method returns an object, and that object can have keys, which are strings, and the value of any key can be anything. And inside that function we need to get a handle on our address, city and country and our online URL. And to get that, we'll start with the address, which is a control, so we'll suffix this with control, and that will equal our control, which is our form group, dot controls, and we want the address. I'm accessing the address property through the indexer syntax like this, which is really the same as doing it like this, except for, because the typescript won't see it that way, and it will give us this error, so instead we use the indexer syntax. And I really don't like this name control, let's call this formGroup, all right. And we also need the city and the country, and finally the online URL. So city's next, then country, and finally the online URL and in this case, since our validator is on a sibling of the online URL, I'm going to actually go up a level by going to the root, and then I want to get to its controls. Unfortunately the type of root, it's just an abstract control, but I actually know that the type is a form group of the parent if we go and look at this model group, its parent is a form, which we can access as a form group by giving it a type, and now that has a controls property, and I can get the online URL. So that's how we go up a level from the node that we're at, which is going to be again, this node here, to get a sibling node, so we have this model group right there, and we want this node right here, and to get its online URL. You'll remember, even though we are looking at nodes in here, it's really a tree structure of controls that we're dealing with when we're talking about the form group and its controls and going up to its root. This is tree structure controls, it reflects the DOM tree, but it doesn't include all of the nodes in the DOM tree. Now that we've got all our controls, we want to write a statement that says either the address, city and country have to be filled in, or the online URL control has to be filled in. So in that case, we write in our if statement and then we want two clauses to that, so we add another set of parentheses. And the first clause is going to be the address, city and country are filled in, and the second clause is going to be an or the online URL's filled in, so another parentheses for that one. That one's a little bit easier, we'll do that one first. The onlineUrlControl has to exist and its value has to exist, so it has to be filled in. And we'll do the same thing with the other clause, which is address, city and country, so addressControl and the addressControl's value has to exist, and the cityControl, cityControl dot value and finally country, and it has to have a value. So there's our if clause, and if this is true, then we want to just return null. Returning a null tells the validation system that this validator is passing, there's no problem. If it's false, we want to return an object with validateLocation as a key set to false. And that matches the type that we defined up here, where key is a string and the value can be anything. And we have a value of false in this key which is a string. So it's going to return either null or this object. If it returns this object, the validator is going to be failing, and we'll get a validation error. And there's our validation control. It's still missing one very important piece before it will work as a validator, but I'm going to talk about that in the next section. So instead let's just add this validator to our dependency injector, by going into the index, and exporting it, and we'll save that and go into the app module and this'll be inside of the events so, find it there. And it's a directive, so I need to add it to the declarations section. And there we go, we can save our changes in both files. We've got our validator created, again it's still not working, we've got more to do, and we'll see that in the next couple of sections.

*/