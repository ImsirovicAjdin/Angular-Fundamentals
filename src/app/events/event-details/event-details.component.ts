import { Component } from '@angular/core'
import { EventService } from '../shared/event.service'
import { ActivatedRoute } from '@angular/router'


@Component({
    templateUrl: './event-details.component.html',
    styles: [`
    .container { padding-left:20px; padding-right: 20px; }
    .event-image { height: 100px; }
  `]
})

export class EventDetailsComponent {
    event:any

    constructor(private eventService:EventService, private route:ActivatedRoute) {
  
    }
    ngOnInit() {
        // this.event = this.eventService.getEvent(1)
        this.event = this.eventService.getEvent(+this.route.snapshot.params['id']) // we're casting to a number with the + in front of 'this' 
    }
}
/*
6.9 Pre-loading Data for Components

So we've taken a look at the canActivate and canDeactivate route handlers, but we haven't looked yet at the resolve route handler. Resolve allows you to prefetch the necessary data for a component or to do other checks prior to loading a component. We haven't really felt the need for this in our app yet because the data is all being provided synchronously from local variables. But this isn't very representative of the real world. Let's change our events service so that getEvents acts asynchronously like it would if we were making an Ajax call. In order to make this asynchronous, we're going to use an RxJS observable. Don't worry too much about the syntax we're going to use here. Joe will talk a lot more about observables in his module on HTTP and observables. But for now, we're just going to go ahead and import Subject from RxJS. And then inside our getEvents method, we'll just create a new Rx observables subject like this. And then in order to make our getEvents method act like it's asynchronous, we're going to use JavaScript's setTimeout method like this. And then we'll just return our observable. Okay, just to explain this a little bit. Observables are like streams of data. They're kind of like arrays, where the data arrives over time. Angular is designed to work very well with both observables and promises. So we're going to take advantage of that. So basically, subject is a type of observable, and right here, we're adding data to this observable stream, and we're doing it inside of setTimeout to simulate asynchrony. So after 100 milliseconds, we'll add data to the stream, and then you can see, right here, that we're returning the observable. We were previously returning the data directly. So we're going to have to go adjust the consumer of this data. That's over here in this events list component. So right here, getEvents is going to return an observable, and you get the data out of an observable by subscribing to it like this. And that's going to eventually return instead of immediately. So instead of setting this. events to the return value of getEvents, we're going to set it only when data is received, which happens inside our subscription. So we can set that like this. And to get TypeScript to stop complaining, let's just change this to any for now. Now, let's go refresh our page. Okay, you can see that's still working, but now we're getting our data somewhat asynchronously, and it's happening through an observable. Again, we'll touch on observables more later. Okay, so let's go add in a little bit more of a delay in our asynchronous method. So let's make this wait for two full seconds. Now, if we refresh, you can see the page partially loads, waits for two seconds, and then finishes loading. This doesn't look so bad on this page, but on some pages, this looks really bad if the page partially loads and then the data pops in afterwards. So let's add a resolve route handler to this route so that we can wait for the data to load before displaying the component at all. To do that, let's go add a events list resolver service. And let's add our basic shell. Okay, so this is an injectible service that implements resolve. In the resolve method, we will typically make an asynchronous method call like an Ajax call. And then when it returns, we'll return that data. So we're going to do that like this. We'll have to inject our event service. Let's fix our typo over here. So this is a very basic implementation. We're calling getEvents, which returns an observable, and then we're calling map on that observable, which gives us access to the events that are passed in on that stream. And if you're not familiar with this syntax right here, we're just returning those events. This is shorthand for this syntax. So we're receiving events in to this function, and then we're just returning them right back out. We can just use this shorthand approach for that. Okay, and one more thing to clarify about what we've done here. Typically, when you listen to an observable, you would call subscribe here instead of map. But because this is in a resolver, we need to actually return the observable to Angular so that Angular can watch the observable and see when it finishes. If we were to call subscribe here, the value that would be returned would not be the observable; subscribe returns a subscription, not an observable. And so we use map, which kind of does the same thing as subscription in this case, and it returns the observable. So then, because we're returning the events inside our map expression, these events will then get passed along to the component to find in our route. Okay, so this resolver is finished now. So let's go consume this resolver, and hopefully it will all start to come together and make sense. So let's add this as a provider in our module so we don't forget. Alright, and we'll add it down here as a provider. Okay, and then we need to add this as a resolver to the route on the events list route. So let's come over here. Okay, so here is our events list route. This is where we want to add our resolver. So it will look like this. Alright, let's import that and then we'll talk about this. Okay, so if we take a look at what we're doing down here, where we're adding this resolve handler, notice that we're passing in an object, and that object has a property, events, and that property value is set to the event list resolver. Okay, so basically, what this is saying is, before resolving this route, call this event list resolver, and when that resolver finishes and returns us some data, add this data to the route as a property named events. So it's going to take the events that are returned from the resolver and put them in a property named events on the route. Okay, so now let's go over to our component and consume that. Okay, so in our ngOnInit, we were calling getEvents and subscribing to that. We don't need to do that any more because we're doing that in our resolver. Instead, that data is now put on the route for us, and we can just get that data right off the route. So let's go inject the route. Inject that here. Okay, now, our OnInit is just going to look like this. Okay, so just to tie this all together. Notice that this events right here matches this events over here on the route. So that's how that's all wired up. The resolver gets the events from the events service, the route takes that and puts it on the route, and then we can access it in our component. Cool, let's check that out. So now I'm going to refresh this. Okay, notice, it's still taking two seconds. But this Upcoming Angular Events that is part of the events list page does not show up until all the data has been loaded. Okay, that's pretty cool. And the great thing is, we only have to load our data once. Notice that our resolver loaded our data for us and put it on the route. So we didn't have to wait for the data to be loaded in the resolver and then load it again in that component. Okay, and just to clean up here. Let's go over to our events service and change this timeout back to just 100 milliseconds. And there's a practice exercise for this clip, so go check that out.


*/