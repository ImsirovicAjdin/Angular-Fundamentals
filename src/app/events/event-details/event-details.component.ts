import { Component } from '@angular/core'
import { EventService } from '../shared/event.service'
import { ActivatedRoute } from '@angular/router'
import { IEvent } from '../shared/index';

@Component({
    templateUrl: './event-details.component.html',
    styles: [`
    .container { padding-left:20px; padding-right: 20px; }
    .event-image { height: 100px; }
  `]
})

export class EventDetailsComponent {
    event:IEvent

    constructor(private eventService:EventService, private route:ActivatedRoute) {
  
    }
    ngOnInit() {
        // this.event = this.eventService.getEvent(1)
        this.event = this.eventService.getEvent(+this.route.snapshot.params['id']) // we're casting to a number with the + in front of 'this' 
    }
}
/*
7.10~ (the rest of the chapter)
Editing Data with Two-way Bindings
Everything that we've done so far with template based forms has been on pages where we are creating data as opposed to editing existing data. For that reason, we've been using the one-way binding version of ngModel that looks like this but what if this was an edit event page instead of a create event page? Let's just demonstrate that temporarily by changing our bindings to point to an event object and pre populating that object with data. So right now our ngModel bindings are just set to primitives. Let's go ahead and update those to be bound to an event object like this. So we'll use event dot name and event dot date, et cetera, throughout our form and notice as we do this, that the ngModel value and the name value don't have to match. So here the ngModel is bound to event dot date but the name of this control is just date. So the name is what's used to populate the form values and the ngModel binding is used for binding to properties on the component. Okay, let's just go update the rest of our fields. And the location ones will be bound to even dot location dot address. Okay, we could go take a look at this and everything would actually be working fine so changing these ngModel bindings didn't change much but let's go over to our component now and add an ngOnInit, and then I'm just going to create an event object here that I'm going to pre populate with this data. You can go ahead and pause this here and type in this data if you want to but we're going to be deleting this in a minute anyhow. Okay, so up here, need to declare event. Alright, so now we have a populated event property on our component. In a real application, we'd be getting this data from an API call but this will suffice just to demonstrate this. Okay, but if we go over now and take a look at our app and go to our create event page, you can see our data is not being pre populated here. That's because we're still using the one-way data binding in our HTML. So everywhere where we have ngModel, we need to change this to a two-way data binding, or the banana in a box syntax, like this. So I'm just going to do a search and replace and replace all of those with the banana in a box style. Okay, now let's go over and take a look at our form. Excellent, now you can see that that data is being populated and then if I edit this data, then save it, then you can see over here that the edited data is what got saved. So you can see how the one-way versus two-way binding works with ngModel. Okay, this really is a create event form not an edit event form. So let's undo what we've added here for editing the event. So I'm just going to hit control Z and undo all these changes and then over here we'll just get rid of our event object and our ngOnInit but that made for a good exercise to show how to edit data.

Diving Deeper into Reactive Forms
We just took a deeper look into template based forms. Let's now take a little deeper look into reactive forms. Right now our event details page is a little boring except for this ridiculously formatted date, which we'll format with pipes in a little while but eventually we want to be able to list sessions for each event so that attendees can see what will be taught when they attend the event. So we'd like to list all the sessions here but first we need a way to create sessions. So let's add a create session page that will use reactive forms. If we go take a look at our session model, you can see that this is what it looks like. So it had an ID, a name, presenter, duration, level, an abstract or a short description, and array of voters for people who upvote the session. Okay, so let's go create a reactive form that we can use to edit this data. We'll put that in the event details folder. So we're just going to add a create session component here and create our basic component, and this will use a separate template file. Alright, let's go add that template file. Alright, let's go grab the basic HTML for that from our helper repo. Let's go in app, events, event details, we have this create session component HTML. Let's grab that and paste that here. Okay, so nothing fancy here, just the basic HTML to edit our session model. Okay, let's add this component to our barrel. Alright, and then we need to just go add this to our app module right here and then down here in our declarations. Alright, now let's go add a route for it. We need to import it. Okay, there we go, so this page will live at events slash sessions slash new and we should be able to hit that now so let's go take a look. So if I go to events slash sessions slash new, okay, cool, here's our new form and you can see we have a few text fields, plus a drop down for duration, and a drop down for level, and an abstract, and if you're curious about those drop downs, let's go take a look at the HTML for that. There's really nothing special here. These are just normal select lists with hardcoded options. Now we could have these options defined in my component somewhere and then I could use ngFor to generate these options but we're just hardcoding them here. Okay, so let's go over to our component and define our reactive form. So first let's import the Angular forms items that we need and then we'll define each of our controls in our OnInit method. Let's create that here. Okay, and then we'll just set up each of our form controls for each of our fields in here and we'll pass in empty data into each one of them and give them a required validator. Alright, and this is going to look the same for the other fields. So we're going to have name, and presenter, and duration, and level, and an abstract. Alright, so we've added required validators to each of these, let's also add a max length validator to the abstract. Okay, so there's quite a bit of validation here and it's going get a little more complex. So you can see how nice it would be to be able to write unit tests to verify all this stuff. Something we can only do if we're using reactive forms. Alright, so now we just need to build a form out of these fields. Okay, so there's our form and now we need to declare each of these variables. So we'll start with the form, which we always declare as a public property so that it can be accessed in our HTML template and let's backspace this a little bit, okay, alright, and we'll declare our form group here. Okay, and then we need to declare each of the fields. Before we do this, let's go take a look at the profile form that we created. So in the profile component HTML notice that whenever we wanted to access one of the controls, we had to do it through the form like this, profile form dot controls dot first name. Well, we had to do it that way because while we made the form public, the form controls were private and that's not really necessary so let's go back to our create session component and let's actually declare these publicly. Okay, now these will be available to us in the HTMl template. So let's go set up our bindings in the template. So first we bind our form to our form group and while we're here, let's wire up our ngSubmit, we'll pass in the form value to a saveSession method. Okay, let's go add that method in the component and we'll just console log the form values again so that we can prove this is working. Alright, and then back in our template, we need to wire up each of our form fields to their corresponding controls and we wire up select lists exactly the same way we do other components and then the same thing for text areas. Okay, that should do it. Let's go take a look at our form. Okay, let's refresh this and enter a new session. Okay, and if I open my console here, and save this, there we go, we can see that our data is being submitted. Okay, and that data shape matches our session model and let's take advantage of the fact that we have a session model that we can use to validate this. So we're going to eventually pass these form values into a service that will save the session for us and, really, we could just pass that as is because it matches the shape of our session model but let's import our ISession interface and map the values over just as a way to sanity check that the shape that we're passing in is correct. So we'll import our session model and then in our save session handler, we'll create a new session object and map each of the fields over from the form values. And you can see that our editor is complaining because this has not yet matched the session model, let's just keep going. Okay, and look at that, it's still complaining because we actually are not adhering to the shape. It's saying that our ID field is missing. Well, we're going to let that be set in our service so we'll just set it to undefined here and then if we look at that again, it's still complaining because voters is missing and this is important and a great example of how the typescript validation can help you in your coding. We actually do need to provide an empty voters array. Okay, there we go, now it's not complaining anymore and then duration actually is a number and we want to cast that to a number. Typescript isn't complaining because the form values that are passed in are of type any and any can be applied to any data type. Okay, and you can decide in your apps whether you want to take this extra step of remapping it to an existing model so that you get the type safety. But for now we're just going to console log this out, we're going to come back and save this later, not in this clip. Okay, so we've defined the validation for our form up here but we still need to make the error messages appear and add our error styling. So let's go do that over here in the HTML. Okay, let's add our error message fields. Okay, notice here that I'm just accessing name directly, I'm not having to say new session form dot controls dot name like we were doing before. That's because we made these form controls publicly available in our component and then also notice that I'm using name dot dirty here instead of name dot touched. The difference between touched and dirty is that if I just put my cursor into a field and then leave that field, it is touched but not dirty but if I start typing in a field then it becomes dirty. I just wanted to demonstrate that dirty option in case you want to use that in your applications. Alright, let's go ahead and add these to the rest of the fields. Okay, and this field has two validators on it so we need to add the extra piece here and the extra error message. Okay, now we just need to add the classes for our styling. Okay, and we'll add that to each of them. Okay, now let's go add our styles. Okay, and let's actually go copy those style from another component because they're going to be the same as the others that we've used. So let's go to our create event component and copy these styles and just add them here. Okay, and then we just need to update this here to apply to our select and text area elements. Now just one more thing, let's just make sure we disable our submit button when the form is not valid. Alright, so let's refresh our page here and notice that I do not get any validation if I just touch the fields, but if I make them dirty, by typing a space, and then invalid, then notice that our validation shows up and if I create a new session, and then open my console and save, there we go, we're getting our data, and it's being mapped to our model and now we have a fairly substantial model based form.

Creating Custom Validators
Okay, we've gotten familiar with using Angular's built in validators but it's not uncommon that we want to create a custom validator to do something beyond what built in validators can do. That's easier to do in reactive forms than it is in template based forms. So let's add one to our reactive form. Let's add a restricted words validator that prevents certain words from being used in a field and then we'll apply that validator to this abstract field. A validator is basically just a function and that function just returns null if the control is valid or an error object if it's invalid. So here in our create session component we'll create a validator function that looks like this. Okay, so this function takes in a form control as its parameter. Alright, and then this function just returns a basic JavaScript object. Don't let this typescript syntax throw you off. This really is just saying that this function will return an object, it doesn't matter what shape the object is. Okay, so our validation function is basically going to check to see if the control's value contains restricted words, something like this. So we'll just hardcode it right now to check to see if it includes the word foo and if it does then it's invalid, because that's a restricted word, and so we'll return an object like this and if the control is valid, meaning it doesn't include the restricted word, then we will return null. Okay, so I've just hardcoded the word foo for now. We'll change this to taking a list of invalid words eventually but this is a simple way to demonstrate what it's doing. So if the control's value contains the word foo, then it is invalid and we return this object and this error object typically has a key that matches the validator name and then you can set whatever you want as the value. This will make more sense when you see how this object's used. So in this case we're going to return the invalid words that were found and right now it's just foo. Okay, we'll come back and make this more intelligent but let's see how this is working if we add it as a validator to our abstract field. So up here I'm just going to add it like this. Okay, so you can see better now that the validator's array is really just an array of functions that should be run to validate the control. Let's go see how this is working. So let's refresh our new session page and then notice that I'm still getting my required field validation and if I type in some text here, we're valid unless that text contains the word foo. So you can see that the field is invalid because the field has turned red but we're missing an error message. So let's go add an error message for our new validator. So over here, I already have two validation messages here, let's add a third one and we want this to still display if it's invalid and dirty but only if it violates the restricted words validator. Okay, and then our message will be restricted words found. Okay, so we've started to use our error object that was returned from our validator here. This restricted words keyword right here matches this restricted words key on our error object. Okay, so we've used the keyword restricted words. What about the value foo? We can also access that in our template. So we can actually use that value right here. We'll say restricted words found and then we'll list the restricted words. Okay, so notice that abstract dot errors dot restricted words is actually that error object. It's the same thing that we're using right here and here. So really that errors object contains any validation errors and the values of the properties on the errors object is actually those validation errors. So let's go take a look at this. If I refresh this now and say whatever foo. There, now it says restricted words found, foo and that foo came from our error object here. Okay, now we'd like to be able to make it so that we can pass in the restricted words to our validator like this. So we want to be able to pass in an array of invalid words like that. Just like we are for that max length validator where we're passing in 400. Okay, there's nothing really Angular specific to do here. We can handle this with just plain JavaScript. Remember that what we actually provide to our array of validators, must just be a function. So if we make it so that restricted words is a function that we call that returns a function, we can make this work just fine. Okay, so down here we're going to make this a function that takes in the restricted words and then we're going to have that return a function, like this, so this is just a fat arrow function from ES6, with some typescript typing information here. Okay, so now restricted words is a function that returns a function and that function is our validator function and now we can access these words right here down inside our inner function. Okay, and this is going to be a little bit more complex because here we just had a string and now words is an array. So our logic is going to look a little bit more like this. So first we'll check to see if words are passed in and if not, then we will return null, which remember makes it so this validator passes. So basically this validator is a no op if you don't pass any words in. Okay, then we will find any restricted words that exist in our controls value. Okay, so this map function is basically looping over all the keywords and checking the controls value to see if it includes that word and then returning that word or null if it's not found and then we just need to filter out those nulls. Okay, so now invalid words contains any invalid words that were found inside the controls value. Okay, and then if any invalid words were found, then we will return the restricted words error object and this time we'll put all of the restricted words in it. So they will be comma separated and otherwise we'll just return null. Okay, so up here we are using our restricted words validator and we're restricting foo and bar. Let's go check that out. Okay, so I can type anything in here expect for foo, notice it says restricted words found, foo, and if I add bar, it also finds that. Alright, cool, that's all there is to creating custom validators. Now we could make this a reusable validator by moving it out of here, let's just do that. So let's move it into our shared folder. So over here, we'll create a new file, restricted words validator, right, let's go grab that out of our component. So we'll take this out of here and move it over here and then we'll just export this. Okay, and it looks like we'll need to import form control. Okay, cool, now we have a reusable validator. Let's just add this to our barrel. Alright, and then we can just import that into our component now. Okay, cool, so now that's being passed in as an import. We can get rid of the this keyword and everything should be working just fine. There we go, now we have a reusable custom validator and there's a practice exercise for this clip, so go check that out.
*/