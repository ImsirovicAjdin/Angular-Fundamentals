import { Component } from '@angular/core'
import { EventService } from '../shared/event.service'
import { ActivatedRoute } from '@angular/router'
import { IEvent } from '../shared/index';

@Component({
    templateUrl: './event-details.component.html',
    styles: [`
    .container { padding-left:20px; padding-right: 20px; }
    .event-image { height: 100px; }
  `]
})

export class EventDetailsComponent {
    event:IEvent

    constructor(private eventService:EventService, private route:ActivatedRoute) {
  
    }
    ngOnInit() {
        // this.event = this.eventService.getEvent(1)
        this.event = this.eventService.getEvent(+this.route.snapshot.params['id']) // we're casting to a number with the + in front of 'this' 
    }
}
/*
7.9
Diving Deeper into Template-based Forms
So far the forms we've created have been really basic like this one. Let's take a look at a couple more forms that have a little more going on. We'll start by creating a template based create event form. We can currently view events in our application but we have no way to create them. We did add this create event component but we haven't created a form for it yet. Let's do that now. If we take a look at this component, the HTML for this is currently in line. So let's delete this and change this to use a template Url and that will live here. Alright, and let's go add that file. Okay, and we'll grab the HTML for this from our helper repo, so under app, in the events folder, we have this create event component HTML and let's just grab all that and paste that in here. Okay, and since we've already gone over the basic form syntax in a prior clip, I've already taken the liberty to wire up the form stuff in this HTML. So you can see our input fields already have ngModel and name attributes and I've already added required field validation to most of our components and the corresponding validation messages and the error styling, except I haven't added any validation to these address or online Url fields. That's because the validation for the location and the online Url fields are a little more complex than we're prepared to handle right now and that's because we want the user to fill out either all of the location fields or the online Url field and we can't really do cross field validation without a custom validator and to do that with template based forms, we need to create a directive so that we can add a custom attribute to the fields that we want to validate. We're not really prepared to do that until Joe talks about directives in a later module. So we'll come back to this validation later after we've talked about directives and so we've added validation to all of our form fields except for these and notice that we have this image Url field that has two validators, a required validator and a pattern validator. So we've added two separate error messages that display appropriately based on which error state we're in. You may remember we did something like this before on the profile form. Alright, and then finally we take a look at our form element, you can see we've already created a template variable for this form and I've wired up the ngSubmit event to this save event method. So let's go add that method. Okay, so over here in our component, we'll add our save event method here and we'll just log out the form values for now and then we just need some styles for our validation messages. Let's just copy that from our profile component because they'll be the same. So I'll grab this styles array and paste that in here, alright, now over in our template we have a bunch of ngModel bindings to these properties that don't exist. So we need to declare those in our component but there are eight or nine of these and I don't really want to clutter up that component that much. We can avoid that by binding to properties on an object instead. So for example for this name binding we can bind to new event dot name. So now this is going to bind to the name property of this new event object. So let's update that for each of these ngModel bindings. So now these are all binding to the new event object and now all I need to declare over in my component is that new event object. So this should work just fine. Alright, now we have this form that we can use to demonstrate a few more concepts. Let's take a look at it just to see the basic functionality working. Before we can do that, though, we'll have to add Angular's forms module to our app module. You may recall doing that before but that was in our user module and this component is in our app module. So let's add that, so we'll just import forms module, and then add it to our modules imports here and actually in one of our next clips we're going to add a reactive form to our app module too, so let's just import that while we're here so we don't have to come back and do that. So we'll add the reactive forms module here and we'll import that here too. Okay, let's go take a look at that. So let's refresh this form. Okay, cool, and if we touch these fields, you can see that the required field validators are working and let's go ahead and fill this form out and then if I open my console, and click save, you can see that our data is being submitted to our component and then logged out but we have a small problem here. Our data doesn't exactly match our event model. If we go over and take a look at our event model, you can see that the address, city, and state fields are nested inside this location object but if we go back and look at the data that's being submitted from our form, you can see that address, city, and country fields are right on the root object, they are not nested inside a location object and we could deal with it and just map it to the right shape in our save method but ideally we'd just get this submitted from our form in the shape that we want. Thankfully, Angular lets us do that in both template based and reactive forms and it's really easy. For our template based form, we just need to wrap our location fields in an ngModel group like this. First I'll just add a div here and then I just need to add an ngModel group attribute and set that to the name of the property that we'd like these fields nested under, which is location, okay, so we'll just wrap these three fields and that div, okay, let's save that and then let's refresh this and put our data back in, okay, so now if I save my form, take a look at this object, notice that we now have a location object inside our object submitted by our form and inside that location object, we have our address, city, and country fields. Wow, that was easy, okay, so that was one major concept that we wanted to demonstrate with this more complex form and then just for fun, let's add a preview image tag so that the user can see the image when they type in the Url in this image Url field. This will just give us an opportunity to demonstrate interacting more with our form and our template. So down at the bottom of our form here, we have this empty image tag. Let's bind its source property to the value of our image Url field and then we don't really want to try to preview that image until the user has entered a valid Url. So let's not display it until that field is valid. I'm using ngIf here instead of hidden because I don't want my browser to try to set the image source at all until the field is valid. NgIf will prevent the image tag from even being added to the dom, so the browser won't even try to render it. If I just used hidden, the browser would try to load the image every time the user typed in the image Url field and so it would it try to load a bunch of invalid Urls, so ngIf is perfect here. Alright, cool, and you can see that we can tap into the validation info and field values wherever we want in the template. So this form's a little bit more complex and you've seen some interesting things that we can do with the more complex form like this. Let's just go finish wiring up our save event method. Okay, so inside our save event method here, we're going to call the event service to save our event and we can just pass form values straight through since the shape of it exactly matches our event model and we'll just have to import this event service. Let's inject that in our constructor. Okay, so that's ready except that we don't actually have a save event method on our event service. So let's go over to that and we'll add one here. Okay, so we're just going to assign an event ID of 999 for now. Of course this really will only allow us to save one new event without having duplicate IDs but we'll come back and make this more robust later and then we also need to default the sessions to an empty array and then we'll just push this onto our events array and let's fix this typo. Okay, so now we have this save event method on our event service that will, for now, just add it our events array. Okay, and then back over to the save method on our component. Let's just copy this down here and then after we save, we'll navigate back to the events list. Now you may remember that we added a route guard on the route for this component that looks at this dirty flag. This will actually prevent us from navigating after we save unless we set dirty defaults. So let's set that. Okay, cool, and now we can add events. Let's just go check that out. Let's refresh this and fill out this form one last time. Okay, now let's save our event. Alright, cool, and you can see we got sent back to our events list page and we have a new Ng Spectacular event that was created using our new create event form that demonstrates a couple more concepts with template based forms.
*/