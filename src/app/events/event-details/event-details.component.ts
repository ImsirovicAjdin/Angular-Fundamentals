import { Component } from '@angular/core'
import { EventService } from '../shared/event.service'
import { ActivatedRoute } from '@angular/router'
import { IEvent } from '../shared/index';

@Component({
    templateUrl: './event-details.component.html',
    styles: [`
    .container { padding-left:20px; padding-right: 20px; }
    .event-image { height: 100px; }
  `]
})

export class EventDetailsComponent {
    event:IEvent

    constructor(private eventService:EventService, private route:ActivatedRoute) {
  
    }
    ngOnInit() {
        // this.event = this.eventService.getEvent(1)
        this.event = this.eventService.getEvent(+this.route.snapshot.params['id']) // we're casting to a number with the + in front of 'this' 
    }
}
/*
7.7
Validating Reactive Forms
One of the benefits of using reactive forms is that we can define our validation in our component where it's unit testable. So let's add a bit of validation to our form. First we'll just make our fields required and validators are just passed in as the second parameter of the form control so we can just use validators dot required and we'll go ahead and add that to both of these. Okay, and we need to import validators from the forms. Okay, so now we have required validators on our two form controls and it is possible to add multiple validators, we'll look at that in the next clip. For now, let's just go make it so that if our save profile method gets called, it won't save the form if it isn't valid. So right here I can say if this dot profile form dot valid then save and navigate otherwise we won't do anything. Okay, so now if we wanted to write a unit test for this, you could see how I could instantiate a new profile component and stub my auth service to return valid or invalid values and then call save profile and validate using a mock whether or not my user gets updated. I could also get access to this profile form property from my tests and directly run tests against it by populating its form controls and then testing the validity of the form. This seems somewhat unnecessary for a trivial form like this but you can see how in a large form with a lot of validation it would be nice to test different scenarios. None of this is possible with template driven forms. Honestly with a small form like this one, template driven might be better because it's so simple but for larger forms, model driven may be better for testability reasons. Before we jump over into our HTML, let's add some CSS styles that we're going to use over there and we're going to do some more interesting styling with this form. So just like we did before, we'll add some styling for an emphasis tag but let's also add an error class that we can add to our input boxes so that we can style our input boxes and then make them turn red when they're invalid. Okay, and for this to look good, we also need to style the placeholder text and there isn't a standard CSS selector for this so we have to use a different one for each browser. Okay, now we can utilize this error class for styling our input boxes. So let's go add this to our HTML. Okay, so let's make our input boxes have our error styling if the field is invalid and the way designed our CSS selectors we need to add the error class to the div element if the field is invalid. So we'll use ngClass if the first name is invalid and the first name field has been touched. Okay, and we want to do the same thing for last name. Alright, let's go check that out in our form and see how that styling's working. So we'll refresh this and log in. Okay, now if we make this field invalid and leave it, there we go, so our styling is being applied to our fields. Now we need an error message to display. So the logic for displaying the error message is actually going to be identical to the logic we just coded into ngClass. So let's actually move this logic into our component so that we can reuse it. So let's copy this out of here and we'll call a method on our controller called validate last name and if that returns false, then we want to add the error class. Okay, and then we're going to do the same thing up here for first name. Alright, let's go add that over here. We'll just add that in right here, so validate last name and we can get the value of our controls off of this dot profile form but it will be more direct if we can just get it right off the controls like this. In order to do that we need to make our controls available outside of just ngOnInit. So let's set these here that let's declare them up here and then down here we just need to say this dot and same thing right here. Okay, now down here we can find out directly from the last name field whether it's valid and touched and this needs to be an or and we want to say valid here. So we're kind of reversing the logic before where we want to return true if this is valid. So we're returning true if it's valid or if it's untouched, alright, and then same thing for first name. Okay, so this will return true if it's valid and then down here we're ______knotting it so we will add the error class if it is not valid. Okay, and now that we have that in place, let's get back to wiring up our error message. So we can just add a couple of emphasis elements and in our ngIf we'll just call our new functions. So if the first name is not valid then display required and then the same thing for last name. Okay, let's check that out. So I've got to log in again and go to my profile form and now if I leave this blank, you can see that it turns red and we get the required message. Only it looks like we missed something on the styling for the color of required. Okay, we're missing a colon right here. Let's refresh this and try again. Okay, there we go. Okay, cool, so now we have validation in place for our reactive form.
*/