
<div class="row" *ngFor="let session of visibleSessions">
    <div class="col-md-1">
        <upvote (vote)="toggleVote(session)" [count]="session.voters.length" [voted]="userHasVoted(session)"></upvote>
    </div>
    <div class="col-md-10">
        <collapsible-well>
            <div well-title>
                {{session.name}}
                <i *ngIf="session.voters.length > 3" class="glyphicon glyphicon-fire" style="color:red"></i>
            </div>
            <div well-body>
                <h6>{{session.presenter}}</h6>
                <span>Duration: {{session.duration | duration }}</span><br>
                <span>Level: {{session.level}}</span>
                
                <p>{{session.abstract}}</p>
            </div>
        </collapsible-well>
    </div>
</div>
<!--
13.03 Adding Voting Functionality
We've got our votingComponent created, now let's implement the functionality. So we've got to react to this vote event through this toggleVote method and we need to implement this userHasVoted method as well. So let's go to our session list component and we'll start off with the toggleVoteMethod. I'm going to put this down here after the onChanges event. That takes a session, which is an Isession and in order to toggle the vote we need to do one of two things. If the user's already voted, then we need to unvote and if the user hasn't voted, then we need to vote. So we're just going to ask if the user has voted which we've got pull up that method anyway so we can call it userHasVoted, passing in the session. And if they have voted, we're going to undo their vote. Now I don't want to implement the functionality here to deal with the data. I'd rather create a service that handled voting functionality, so I'm just going to call that voterService and I can call deleteVoter. And of course, it will need to know the session and it will also need to know the user name of the current user. If we go into our event service, you can see that the data for a given session has a voters array, which is just the user names of users. So we're going to need to know the user name because when we undo their vote, we need to find it and remove it from this array. In order to get that, down here in our user folder we have the auth service. And the auth service has a current user, and that current user has a userName property. If we go back to our session list, we can say this dot auth service, I'm just going to call it auth dot current user dot userName. And now if they haven't voted, then we have to act differently. We need to vote for them, so in this case we're going to call voterService dot addVoter, again, same parameters, the session and the userName. And finally, since we're changing the number of votes, if they're sorting by votes, we want to update the sort. So we'll say if this dot sortBy is votes, then this dot visibleSessions dot sort, and we're going to sort by votes descending. All right, so there's our toggleVote method. The first thing we need to do to make this work is to implement the userHasVoted method, which, again, belongs to this same component. That takes in a session, which is an Isession and we can return this dot voterService dot userHasVoted, passing in the session and the userName. So now we need to bring in the AuthService and our voterService. The voterService hasn't been created yet, so let's first bring in the AuthService. So I'll go up here and import from up two directories user slash auth dot service. We are in event details, which is underneath events which is a sibling to users, so we had to go up two, and inside of there is the AuthService, and then we'll need to add that to our constructor and inject it, so let's create a constructor. Create the AuthService and we'll also need the voterService but we haven't created that yet, so let's create the voterService. And we're just going to put that in the same directory as event details, since this service is unlikely to be used by anybody else. Since the service you want it to be injectable, meaning we want to be able to inject other services into it, so I write import Injectable from angular core. We'll call that Injectable decorator, create our class, and it has to have the three methods that we referenced back in our session list component, deleteVoter, addVoter and userHasVoted. So deleteVoter will be our first one. It takes in a session which is an Isession and a voterName which is a string. We need to import this Isession type, from the model which is up in shared slash event dot model. And now to delete a voter, we're going to want to adjust the voter's array, so we're going to update that. And we're going to do that by filtering it. We get the voter, which is the name of the voter, and so we're going to filter on if the voter or their username does not equal the voter name that was passed in as a parameter. So for whatever element in that array has that voter name, it's going to get filtered out. Everything else will be included so the new array that's created through this filter method will be all of the voters except for whatever one matched the username. Add voter will be a little bit simpler. Same signature, but this time we just do session dot voters dot push voterName. And finally, userHasVoted, same signature, and in this case we will return a boolean variable. And we'll just call this some method, which is the method on an array that will return a boolean whether there is or is not at least one element that matches a specific condition, and that condition will be that the voter is that same as the voterName passed in. So if the value of the element of the array, the current element of the array is the same as this, then we're going to get a true, and therefore this whole method will return true. It will keep scanning through until it finds at least one record that returns true. If it gets to the end and none of them are the same, then it will return false. So now we've got our three methods implemented, we can go back to our session list. And we need to import that voterService. Grab that, and we will inject it into this class, and of course, since we just created that service, we need to add it to our index file, so let's save our change here and go to the index file and add that service, and then go to our module, and we'll import the service and add it as a provider, to the whole module, and now if we go back to browser, I'm not going to refresh, I'm going to go to the events page and then refresh, and there's a reason for that. And that is that voting functionality requires a current user. I wasn't logged in, and even if I was, when I refresh, the client loses the knowledge of the currently logged in user and you're logged out again. And so the details page will break, and we can see that here if I click into the details page. Notice it's completely broken. So let's go back to events, and I'll log in. And now if we click on an event, the voting functionality is there and I can click on it and we go from the empty heart to the filled in heart. If we go from three to four, then we get the flame icon next to the session. So this is the basics of the voting service and in the next session we'll address this issue about having to be logged in.    
-->