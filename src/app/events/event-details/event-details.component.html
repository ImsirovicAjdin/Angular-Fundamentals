<div class="container">
  <img [src]="event?.imageUrl" [alt]="event?.name" class="event-image">

  <div class="row">
    <div class="col-md-11">
      <h2>{{event?.name | uppercase }} </h2>
    </div>
  </div>

  <div class="row">
    <div class="col-md-6">
      <div><strong>Date:</strong> {{event?.date | date:'short' }}</div>
      <div><strong>Date:</strong> {{event?.date | date:'shortDate' }}</div>
      <div><strong>Date:</strong> {{event?.date | date:'y/M/d' }}</div>
      <div><strong>Time:</strong> {{event?.time}}</div>
      <div><strong>Price:</strong> ${{event?.price}}</div>
    </div>
    <div class="col-md-6">
      <address>
        <strong>Address:</strong><br />
        {{event?.location?.address}}<br />
        {{event?.location?.city}}, {{event?.location?.country}}
      </address>
    </div>
  </div>

  <hr>

  <div class="row">
    <div class="col-md-2">
      <h3 style="margin:0">Sessions</h3>
    </div>
    <div class="col-md-7">
      <button class="btn btn-default" [class.active]="" (click)="">All</button>
      <button class="btn btn-default" [class.active]="" (click)="">Beginner</button>
      <button class="btn btn-default" [class.active]="" (click)="">Intermediate</button>
      <button class="btn btn-default" [class.active]="" (click)="">Advanced</button>
    </div>
    <div class="col-md-2">
      <a (click)="addSession()">Add Session</a>
    </div>
  </div>

  <session-list *ngIf="!addMode" [sessions]="event?.sessions"></session-list>
  <create-session *ngIf="addMode" (saveNewSession)="saveNewSession($event)" (cancelAddSession)="cancelAddSession()"></create-session>
</div>

<!--
10.04 Sorting and Filtering Overview
In this section, we're going to get an overview of how we filter and sort data in Angular 2. There's no built in order by or filter by pipe in Angular, so in this section we're going to dig in a little bit, so that we can understand why. But in order to do that, we will first need to talk about identity and mutability, which is the opposite of a current hot topic you've probably heard about, immutability. Once we understand those concepts, we will talk about why in Angular we don't use pipes for filtering and sorting. It's helpful to understand that variables that contain primitive data, like numbers, are kept in a specific kind of memory where the variable name and the data are together. I've created a diagram of these different memory slots shown in orange. These are the variable A and B, which we can see the code on the left has assigned each of them to three. This creates two different variable slots, each containing that value of three. When I compare them, I get true, because three is three, and with primitives, we just compare the values. Now if I assign a new variable, C to A, it creates a new slot named C, that has a three in it. When we compare these variables, again they return true, because they contain the same value. But when we change the value of one of them, so let's assign four to A, the effect is that the variable slot for A now contains a four, but C and B still contain three. A is now different from B and C, an if we compare them, they return false. Object identity on the other hand, is different. Objects are stored differently in memory. Object variables don't contain data like they do with primitives. They are pointers to the data. Here I've got an A variable and a B variable that each point to an empty object. In this case, just like with primitives, I created two different values, which you can see in the code on the left. The big difference is that when I compare them, the result is false. With objects, Javascript doesn't just care if the values look identical. They are two different objects, so the comparison returns false. By the way, none of this has to do with either double equals or triple equals. That's only about type conversion. So don't think that any of this is different depending on what comparison you use. So now, if I create a C variable and assign it to A, it behaves differently from primitives. It doesn't create a new empty object, it just points C at the same value as A. And of course, this will return true if we compare them, because A and C are now pointing at the same exact object. Now we can change A. With objects, we change them by mutating the object. So here I'm adding a var1 property to the object that A points at. That changes the actual data. Notices that C still points at this data. So now, if we compare A and C, they are still the same object, so they still return at true. Let's back up now. Instead of mutating the object by adding a property, let's assign A to a new object. This, then creates a new memory slot with that value, and A no longer points to the old slot, it now points to the new slot. And now it's obvious that if we compare A and C again, they are different. C still points to the old object that A used to point to, but A now points to a new and different object. The next concept we need to understand is mutability, and how that affects change detection. Mutability is the fact that things like objects can change. With ordering and filtering in Angular, we're obviously talking about lists of data. We order and filter lists. In Javascript, lists are implemented with arrays, so we'll start talking about arrays. Remember, arrays are just a specific kind of object in Javascript, so all the rules that we learned about identity with objects applies to arrays as well. Here I have a simple array with two items in it. These are users, Dave and John. If something happens in our program, Angular needs to know what it should re render, so it runs through a change detection cycle. Let's say that we delete the John user. Now Angular wants to know if the array has changed, so that it can display the new set of data on the page. You might think it could simply check the length property and notice that the length used to be two, but is now one. But what if, in addition to removing a user, we added an entirely new user? In that case, the length of the array hasn't changed, but the data has. Notice that we didn't change the second user object. We truly deleted it and added a new user. Now imagine this isn't an array with two items, each with only one property, but instead it's thousands of items with dozens of properties each. In a typical scenario we'd want to filter and sort. The algorithm to compare the new values in the array to see if it has changed is a very long and complex algorithm, and can end up taking a long time to run. This is one of the core performance problems in Angular 1. This is mutability. Objects and arrays in Javascript are mutable. They can change any time without changing their identity. Now let's complicate the matter with a pipe, which we're trying to use to sort our data. The situation is the same for filtering, but we'll use sorting as our example. Here we have our user array, but we're going to run the data through a theoretical sorting pipe, so that the data can display sorted. We ran it through our pipe and the data is not sorted. That's great, but what if we change our source data? Here we've changed the Dave user's name from Dave to Ralph. Now the resulting sorted data is incorrect, and out of order. We want the display to update. Angular needs to know about that change, but remember that to tell if the array has changed, it has to go through each item and each property to see if things have changed. This can be a rather expensive operation, so by default, Angular only runs a pipe when the identity of the source data has changed. Remember that in past sections we were running primitive data through pipes, strings, numbers, and dates. So this works great, because comparing an identity is so quick, you could do it hundreds of thousands of times or even millions of times every second, and still have plenty of CPU cycles left. But with filtering and sorting, the source data will be objects, so the identity isn't going to change, so the pipe isn't going to be re-run, and therefore, the display isn't going to be updated. There is another option. This is called an impure pipe. Impure pipes run on every cycle of the change detection engine. This is a problem because that means that the sorting or filtering operation you write, will now run unnecessarily every time an event happens in your application. Let's say, you're listening to the mouse move event, and every time you move the mouse around, your pipe is going to execute and produce the new filtered or sorted view of the data, multiple times, possibly hundreds or even thousands of times. Don't forget that the results have to be re rendered to the DOM. This method of executing the filtering or sorting code every time change detection runs is how Angular 1's filters worked, and this is one of the reasons that Angular 1 often had performance problems. So even though, Angular 1 let you shoot yourself in the foot this way, in Angular 2, that ability has been hidden. Pipes are no longer recommended as the way to filter and sort your data. Now, the recommended way is to filter or sort your data in the component that displays the data. That way you can update the filtered or sorted list whenever the source data changes, which you will know about, since it's your code that has to actually change the data. It also means that instead of a generic filtering or sorting method that has to work for every scenario, you can write this code yourself so that it can be customized to be efficient, and that's what we're going to do in the next sections. We're going to add filtering and sorting to our application, but we're not going to use pipes, even though we're in the module about pipes. This functionality is very common and we need to understand how to do it, but we also need to see how to do it correctly.
-->