<div>
  <h1>Edit Your Profile </h1>
  <hr>
  <div class="col-md-4">
    <form [formGroup]="profileForm" (ngSubmit)="saveProfile(profileForm.value)" autocomplete="off" novalidate>
      <div class="form-group" [ngClass]="{'error' : !validateFirstName() }">
        <label for="firstName">First Name:</label>
        <em *ngIf="!validateFirstName() && profileForm.controls.firstName.errors.required">Required</em>
        <em *ngIf="!validateFirstName() && profileForm.controls.firstName.errors.pattern">Must start with a letter</em>
        <input formControlName="firstName" id="firstName" type="text" class="form-control" placeholder="First Name..." />
      </div>
      <div class="form-group"  [ngClass]="{'error' : !validateLastName() }">
        <label for="lastName">Last Name:</label>
        <em *ngIf="!validateLastName()">Required</em>
        <input formControlName="lastName" id="lastName" type="text" class="form-control" placeholder="Last Name..." />
      </div>

      <button type="submit" class="btn btn-primary">Save</button>
      <button type="button" class="btn btn-default" (click)="cancel()">Cancel</button>
    </form>
  <div>
</div>

<!--
(11.04) Using Angular's InjectionToken
Let's start off by deleting this class. Now, because of that I don't need injectable anymore. What I want out of the service class is to create a key, or a token that I can use to register with Angular's dependency injector, so that whenever I want an instance of the Toastr class, I can use that key or that token as a way to look it up and find the instance that I want. Now, there's actually a way to do this, Angular provides a mechanism for us to create a key or token that we can use, in the dependency injector, without creating a class, and that is called the injection token. The injection token's job is simply create a token, used for the dependency injection registry, in order to find the instance of the service that we want. I'm going to export let, and then I'm going to use caps. This is a convention that is often seen with tokens. I'm going to call this Toastr underscore token, and that's going to equal a new injection token. Now, the injection token's constructor takes in a type parameter, and that type is the type of the object that is given back for the service. When we use this token to look up the instance of our Toastr Service, this is the type that's given back. We have not created that type yet, we're going to create it in just a second, so I'm going to leave this blank for a moment. Then the constructor takes in a single parameter, which is a string, which is the description. This is just using debugging, it's not particularly important what you put in here, other than that it's a string that you might recognize, so I'll just put in Toastr. What this is doing, this is creating a token that I can then use to look up the Toastr object inside of the dependency injection registry. I haven't registered it yet, I've just created the token. We're going to register it over in the app module, just a second. Now it's important to relay something, even though I'm passing in a string here, this object right here is not a string. This is an actual JavaScript object. If we remember, back in previous sections, when we were talking about identity, if you have objects, two objects that look identical, are not the same object. We've created an actual object and as long as we export this object, and use the specific object to look up in the dependency injector, nobody else can accidentally use the same token or key, in the dependency registry, so we don't get any conflicts. If I were to use a string, then nobody else could use that string with their service. If they accidentally did, we'd get a conflict. But, because this is an object, somebody else can have another injection token that they happen to feed in this same string, It doesn't matter what they name their object, or what they put it in as the string, because it's going to be a different instance of an object. They might look the same, but they will definitely be two different instances, so they'll be different in the dependency injection registry. In our app module, when we import, we're going to import a specific object from a specific service, so here I'm going to import that Toastr token. It doesn't matter if somebody else were to import another token with the same name, maybe do something like this, but from a different Toastr Service, say Toastr 2 Service, and that also exported a Toastr token, we would have to rename that using something like this. We would be using two completely different injection tokens, two different instances of two different objects, so we don't have any name collisions. Now that I've got the token, I can register the service with the Ng Module, but unfortunately I've got to go back into the Toastr Service and I've got to pull this declare statement out right here, because I have to have the Toastr object, this global object, declared in the app module where I use it. Remember what this statement is, this is just a little statement using TypeScript to say that there's already a global Toastr object, so that I can use it inside of my TypeScript and I don't get any errors. I have to pull it out, and I have to move it over to the app module. I'm going to put it right here, and right down here I've got the Toastr service, but this is no longer valid, I've got to create a new dependency objection registration. I'm going to use that token and I'm going to say that whenever we want the Toastr object, we'll just use our token to find it. That's basically what we're doing with all of our other registrations right here. We're saying whenever you want the event route activator instance, use the event route activator class. We're going to be doing the same thing. The way that we do it, is the exact same way that we did it down here for the can deactivate create event provider. We use the longhand provide, and this is going to be the token and then we tell it we're going to use a value. The value that we want to use is that global Toastr object. That is now our registration for the Toastr object. We're telling Angular's dependency injection, that when somebody wants the Toastr object, they have to ask for it using the Toastr token. With the registration completed we can go back to our Toastr service, and remember we still have an issue here, the injection token needs a type parameter. I could of course just say any, and that would be just fine. I'm telling TypeScript that I'm not going to give it any information about the shape of whatever this service is going to return, using this token. It's a pretty simple service, the Toastr Service. I can actually use TypeScript and create an interface for it very simply. I'm just going to paste in this interface that I've already created. It's very straightforward, four methods, each methods has two parameters, the second one is optional, really easy simple interface. Now I can set that as the type of the injection token, and clean up a little bit here. Now I can go back into the app module and right up here where we declare the Toastr variable, I can actually give it the correct type, that interface. I've got to grab it from this import statement, and now I can use that as the interface. This isn't going to benefit us right here, because we're not actually using this Toastr, so we're not doing anything in this file with it other than using it in the registration there on line 50. Later on when we actually consume this service, we can use that interface to get Intelliscence. Finally, we do need to do a little bit of cleanup, because we're using the Toastr Service in one place in our project. Let's save this change, and let's open up events list component. You can see that we're using the Toastr Service here, so let's delete that line. We we're using this click event, but now we're just routing using a routing component. We don't even need that click event anymore, so we can delete that and we can delete the handler for it, and get rid of the construction parameter. And we've got our clean and complete. We'll save that change and close the file down. In our next clip, we will look at how to get ahold of our new Toastr Service.
-->