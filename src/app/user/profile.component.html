<div>
  <h1>Edit Your Profile </h1>
  <hr>
  <div class="col-md-4">
    <form [formGroup]="profileForm" (ngSubmit)="saveProfile(profileForm.value)" autocomplete="off" novalidate>
      <div class="form-group" [ngClass]="{'error' : !validateFirstName() }">
        <label for="firstName">First Name:</label>
        <em *ngIf="!validateFirstName() && profileForm.controls.firstName.errors.required">Required</em>
        <em *ngIf="!validateFirstName() && profileForm.controls.firstName.errors.pattern">Must start with a letter</em>
        <input formControlName="firstName" id="firstName" type="text" class="form-control" placeholder="First Name..." />
      </div>
      <div class="form-group"  [ngClass]="{'error' : !validateLastName() }">
        <label for="lastName">Last Name:</label>
        <em *ngIf="!validateLastName()">Required</em>
        <input formControlName="lastName" id="lastName" type="text" class="form-control" placeholder="Last Name..." />
      </div>

      <button type="submit" class="btn btn-primary">Save</button>
      <button type="button" class="btn btn-default" (click)="cancel()">Cancel</button>
    </form>
  <div>
</div>

<!--
(11.03) Angular Dependency Injection Lookup
Let's start by going back to our profile page. Going down to the profile. component. ts. Let's look at the constructor, and let's talk about this AuthService right here. Now you've learned that if you want to inject something like the AuthService, that we wrote, that you have to import the AuthService from its file. Then, using the constructor, mark it as a parameter and mark the type correctly. This type here is the class, if we were to go into the AuthService, we can see that we're exporting a class off service and this class wrapper, this ES6 class functionality, is just syntactic sugar for a constructor function. What we're getting out of this is just a function. Inside of our profile component, where we inject that, we're marking that parameter with this type. But, what we want is an instance of the AuthService. We don't want the class, we don't want the constructor function, we want an instance of that. We want an already created instance of that. And so, what we want, is for Angular 2 to take the AuthService class, create an instance, and give us that instance. And that's exactly what Angular 2 does. When we register the AuthService class, Angular 2 will create an instance of that class, and give us that instance whenever we reference it in a constructor function and that happens inside the app module. We can see that here in the app module. We are bringing in the AuthService class right down here. We register that under the providers section. What's going on behind the scenes, is that Angular is taking this class and creating an instance of it, for us to get whenever we inject it. And again, if we go back to our profile component, that's what happens. We're getting the instance that it created. Now, the question is raised, how does Angular know that we want the instance of the AuthService... And let's go back to app module. How does it know we want an instance of the AuthService, and not the even list resolver? How does it know? Well it's this marking right here. This TypeScript type declaration. Angular 2's hijacking that declaration and using that as a way to look up the service that we're looking for. Essentially, what it's doing, is it's using the class as a key to find the correct object, in this case the instance of the AuthService that's been created, inside of it's dependency injection registry. In Angular 1, we used strings as keys. You'll recognize this syntax if you're familiar with Angular 1, we would call Angular dot module and pass in module name, like app for example, and then we would call the service or factory functions. The first parameter would be a string, and the second parameter would be a function that returns whatever object we want to be that service in the dependency injector, but the key was this string, my service, whenever we wanted an instance of that service, we would have to create a parameter that had that same exact name. It was a string match up, and of course that came with all the problems of using strings. If you happened to mistype the name, then it wouldn't find your service correctly and wouldn't be able to look it up. Strings were how Angular 1 registered dependencies. In Angular 2 we're using classes, or types. That's our key, or in other words our token. This tells Angular 2 to find the correct object to give to us. So again, what Angular 2 is doing is, it's hijacking this type declaration, this serves two purposes now. One purpose is to type it so that in our JavaScript code we get auto complete. If I type in AuthService and a dot, I get this nice Intelliscence that tells me what the methods of the Auth service are, and that's because TypeScript is reading the type declaration right here. In addition, Angular 2 is using that type declaration to look up the correct object inside of its dependency injection registry, so it's using it again as a key. Of course this works just great, because whenever we want to create a service, we create a class. For example, when we want to create our Auth service, we're creating a class, export class AuthService. But, there's a problem with Toastr and that is the Toastr is already an object, it's a global object. We didn't create a Toastr class that we can export and then use as our key inside of our app module. I can't come up here and import the Toastr class, and then add it to the providers array. What I don't want, is this class, this wrapper class, but I still need some kind of a key to give to Angular, so that it can use it as a key to look up the item in the registry. I will fix that problem next.
-->